
# API и интеграции системы «Умная премия»

## 1. Авторизация

### 1.1 Telegram WebApp
- Используется `initData` для верификации пользователя.
- Backend проверяет подпись `hash` и идентифицирует пользователя.
- После успешной проверки создается сессия (JWT или cookie).

### 1.2 Корпоративный аккаунт (опционально)
- OAuth2 / SSO.
- Получение токена доступа для API.

---

## 2. Эндпоинты фронтенд → backend

### 2.0 Получение текущей сессии (веб/мобильный клиент)
- **URL:** `/api/v1/sessions/current`
- **Метод:** GET
- **Описание:** Получение активной сессии голосования для фронтенда.
- **Ответ:**
```json
{
  "session_id": 17,
  "start_date": "2025-10-20",
  "end_date": "2025-10-26",
  "active": true
}
````

> Frontend использует `session_id` из этого ответа при отправке голосов.

---

### 2.1 Голосование

* **URL:** `/api/v1/votes`
* **Метод:** POST
* **Описание:** Отправка оценок за коллег (включая себя)
* **Запрос:**

```json
{
  "session_id": 17,
  "votes": [
    {"user_id": 101, "score": 8},
    {"user_id": 102, "score": 7},
    {"user_id": 103, "score": 9}
  ]
}
```

* **Ответ:**

```json
{
  "status": "success",
  "message": "Оценки сохранены"
}
```

#### Пояснения:

1. `voter_id` определяется **из аутентификационных данных**, а не из JSON:

   * Telegram WebApp: `user.id` из `initData`
   * Веб: JWT / корпоративная сессия
2. Backend проверяет:

   * Сессия активна (`session_id`)
   * Пользователь ещё не голосовал за этих коллег в текущей сессии
   * Голос не превышает допустимый диапазон (0–10)
3. Голосование **безопасно**: нельзя подделать `voter_id`.

---

### 2.2 Просмотр результатов (сотрудник)

* **URL:** `/api/v1/results/me`
* **Метод:** GET
* **Описание:** Получение собственного рейтинга и статистики
* **Ответ:**

```json
{
  "user_id": 101,
  "average_score": 7.8,
  "rank": 3,
  "votes_given": 5,
  "votes_received": [
    {"from_user_id": 102, "score": 8},
    {"from_user_id": 103, "score": 7}
  ]
}
```

---

### 2.3 Просмотр результатов (админ)

* **URL:** `/api/v1/results/session/{session_id}`
* **Метод:** GET
* **Описание:** Получение всех голосов и рейтингов за сессию
* **Ответ:**

```json
{
  "session_id": 17,
  "results": [
    {"user_id": 101, "average_score": 7.8, "votes_received": 5},
    {"user_id": 102, "average_score": 8.2, "votes_received": 5}
  ]
}
```

---

## 3. Управление сессиями (админ)

### 3.1 Создание новой сессии

* **URL:** `/api/v1/sessions`
* **Метод:** POST
* **Запрос:**

```json
{
  "start_date": "2025-10-20",
  "end_date": "2025-10-26",
  "active": true
}
```

* **Ответ:**

```json
{
  "status": "success",
  "session_id": 17
}
```

### 3.2 Закрытие сессии

* **URL:** `/api/v1/sessions/{session_id}/close`
* **Метод:** POST
* **Ответ:**

```json
{
  "status": "success",
  "message": "Сессия закрыта"
}
```

---

## 4. Управление участниками (админ)

### 4.1 Добавление / обновление сотрудника

* **URL:** `/api/v1/users`
* **Метод:** POST
* **Запрос:**

```json
{
  "user_id": 101,
  "name": "Иван Иванов",
  "active": true
}
```

* **Ответ:**

```json
{
  "status": "success",
  "message": "Пользователь добавлен/обновлён"
}
```

### 4.2 Пометка сотрудника как неактивного

* **URL:** `/api/v1/users/{user_id}/deactivate`
* **Метод:** POST
* **Ответ:**

```json
{
  "status": "success",
  "message": "Пользователь помечен как неактивный"
}
```

---

## 5. Экспорт данных (админ)

* **URL:** `/api/v1/export/session/{session_id}`
* **Метод:** GET
* **Описание:** Получение XLSX или CSV файла с итогами голосования
* **Ответ:** файл для скачивания

---

## 6. Безопасность

* Все эндпоинты требуют аутентификации (JWT или сессия)
* Разграничение ролей: сотрудник / админ
* Валидация всех входных данных и проверка подписи Telegram для предотвращения подделки голосов
* Проверка session_id на активность перед принятием голосов

---

## 7. Интеграции

* Telegram Mini App → Frontend → Backend API
* Возможная интеграция с корпоративной системой SSO для авторизации
* Экспорт данных для бухгалтерии и HR-систем (XLSX/CSV)
* Опционально: уведомления через Telegram / email (асинхронно через Celery/Redis)

---

## 8. Пример потока голосования

1. Frontend делает GET `/sessions/current` → получает `session_id` активной недели.
2. Пользователь открывает форму голосования, выбирает оценки коллег.
3. Frontend отправляет POST `/votes` с `session_id` и оценками.
4. Backend:

   * Определяет `voter_id` из initData или JWT
   * Проверяет активность сессии и пользователей
   * Сохраняет голос
5. После окончания недели админ может GET `/results/session/{session_id}` и экспортировать данные.

